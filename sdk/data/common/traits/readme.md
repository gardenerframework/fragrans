# 特性(Trait)的定义

特性是指一个属性的名称和类型，以及属性对应的业务领域约定，比如

```java

@Trait
public class Name {
    private String name;
}
```

就定义了名称这一特性，其属性的名字被标准化为"name"，类型被标准化为"String"

通过约定特性以及在记录、参数、响应等数据结构上实现特性接口，使得数据能够自我表达所属的业务领域知识，有助于程序员阅读代码

# 特性的分类

将所有个性都放到一个jar包中显然是不合适的，这会造成类过多后，java程序所需的内存显著提高，需要对特性进行分类

## 按业务领域分类

从jar包上，按照特性所属的业务领域进行分类，方法是:

* 现实世界
    * 生命体(与或者的生命相关)
        * 人类(data-traits-mankind): 包含人类相关的若干属性命名，比如个人信息，住址，联系方式等
        * 社会(data-traits-society): 包含社会相关的若干属性命名，比如政府和公司等相关的名称和属性等
        * 学科/行业专用词: 学科专用名词来将某个学科或者行业的专用名词进行汇总，比如航司专用的，医学专用的，铁路交通专用词等，每一个行业是一个单独的jar包
        * 通用型生物特征(data-traits-bio): 包含作为生命基本具备的特征和属性，比如身高，体重，血型等等
    * 非生命体(与无声明物体相关，比如星球，宇宙以及自然资源)
* 计算机电子世界
    * 网络(data-traits-network)
    * 程序和编程(data-traits-programming)
    * 应用程序(data-traits-application)
    * 账户(data-traits-account)
    * 数据结构(data-traits-data-structure)
    * 安全与审计(data-traits-security)
* 中立的通用词语(data-traits-generic)

从分类上，jar包是一级分类，包内允许对特性的一级名称空间进行二级业务领域划分，比如

```java
public interface MankindTraits {
    /**
     * 和联系方式相关的特性
     */
    interface ContactTraits {
        ///...
    }
}
```

但是不推荐再执行三级或甚至更多级的划分，过细的分类首先让使用者难以理解且大量的精力耗费在了如何分类而不是代码实现上

# 二级分类法

上文表达了一级分类法，也就是jar包的分类以及按照业务领域或实体所属的领域进行分类的约定，在一个已经按照领域切分的名称空间内部，如果不存在子领域，则按照以下分类分类方法执行

* 识别符号(Identifier): 意味着特性可能用来识别个体，包含在关系表或对应中识别个体的特性
* 文本数据(Literal): 意味着特性是一个文本，比如名字，描述，备注，说明，看法等
* 标识位(Status): 意味着特性是一个标志位，标志为通常为"boolean"，也有使用"bit"作为标志位的
* 时间(Datetime): 意味着特性指向一个时间节点
* 视觉(Visual): 意味着特性表达一个图像或视频
* 分组(Grouping): 意味着特性用于分类、分组、圈定特定个体

以上分类是当特性过多时，或有明显所属的分类时执行。此外，如果领域内的特性不多，当前很难聚合则不用硬分

# 例子

```java
public interface MankindTraits {
    /**
     * 和联系方式相关的特性
     */
    interface ContactTraits {
        class Email {

        }

        class Wechat {

        }

        class Alipay {

        }
        //...
    }
}
```

一级分类是"人类"，二级是"联系方式"，联系方式下，微信，支付宝显然属于社交网络的概念，但二级分类下尽量不要再构造三级业务分类，因此采取了平铺的方式。 如果感觉到别扭，那么微信号、支付宝号用于识别一个对象，可以列为"Identifier"
